## 인덱스 구조 및 탐색
- 데이터베이스에서 데이터를 찾는 방법은 두가지다.
  - 테이블 전체를 스캔한다
  - 인덱스를 이용한다.

이러한 인덱스 튜닝 방법의 핵심은 크게 두가지다
- `인덱스 스캔 효율화 튜닝`과 `랜덤 io 최소화 튜닝`
```
예를들어 시력이 1.0~1.5인 홍길동을 찾고자한다고 해보자!!

만약 이름과 시력을 인덱스로 잡으면 먼저 이름으로 정렬, 시력으로 정렬이 되어있을것
이름으로 정렬되어 있으니 홍길동을 찾고, 그 다음 시력 조건을 만족하는동안 수평 스캔을 진행하면 된다.

하지만 만약 시력, 이름으로 인덱스가 잡혀있다면 효율이 매우 나쁘다.
이것이 바로 인덱스 스캔 효율화를 고려하는 튜닝이다.
```
- ![image](https://user-images.githubusercontent.com/62214428/213105706-2db06119-da1c-4695-847b-9a0d2c6e120c.png)
- ★ 다음으로 사실 가장 중요한건 결국 테이블 액세스 횟수를 줄이는것이다
- 인덱스는 랜덤 io를 사용하니 즉. `랜덤 io 최소화 튜닝`

### sql 튜닝은 랜덤 io와의 전쟁이다
```
랜덤 I/O와 순차 I/O

랜덤 I/O는 읽어야하는 데이터가 물리적으로 불연속적으로 있기 때문에 디스크 헤더를 이동 시킨 다음 데이터를 읽는 것을 의미한다. 
이때 디스크 헤드를 이동시키는 시간을 Seek time이라고 한다. 
순차 I/O는 읽어야하는 데이터가 연속적으로 있어 쭉 읽기만 하는 경우를 의미한다.

데이터를 3번 읽어야 한다고 가정하자. 데이터 위치가 물리적으로 연속적이라면 디스크 헤드를 한번 이동시키면 되지만, 불연속적이라면 디스크 헤더를 3번 이동시켜야한다. 
즉, Seek Time이 사실상 디스크에 데이터를 읽고 쓰는데 걸리는 시간을 좌우한다. 
따라서 디스크의 성능은 디스크 헤더의 이동 없이 얼마나 많은 데이터를 순차적으로 저장하느냐에 달렸다.

SSD는 디스크 원판이 없어서 랜덤 I/O와 순차 I/O가 큰 차이가 없을 것 같지만 SSD에서도 랜덤 I/O는 순차 I/O 대비 전체 처리율(throughput)이 떨어진다.

DBMS는 디스크에 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에서는 그룹 커밋이나 바이너리 로그, InnoDB 로그 버퍼등의 기능이 내장되어 있다.

쿼리를 튜닝한다고 랜덤 I/O가 순차 I/O로 변하는 상황은 많지 않다고 한다. 
즉, 쿼리 튜닝의 목적은 랜덤 I/O 횟수 자체를 줄이는 것이다. 
즉, 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것이 중요하다.

인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하고, 풀 테이블 스캔은 순차 I/O를 사용한다. 
따라서 큰 테이블의 레코드를 읽는 작업을 할 때 옵티마이저가 인덱스 대신 풀 테이블 스캔을 하도록 유도하는 경우도 있다고 한다.
```

### 인덱스 구조
- 인덱스는 정렬되어 있고 그렇기 때문에 범위 스캔 range scan이 가능하다
- 이로하여금 모든 데이터를 풀 스캔하는것보다 효과적일 수 있다.
- 그런데 이 말은 곧 정렬된 데이터를 사용하기 위해선 시작점을 찾을 수 있어야한다.
- 즉 인덱스 선두 컬럼이 가공되지 않아야 인덱스 range scan이 가능하다.
- ![image](https://user-images.githubusercontent.com/62214428/213107578-8d10d138-605c-4a32-9b51-3e3b38a94734.png)
```
인덱스의 동작 방식은
수직 탐색 + 수평탐색이다.
수직적 탐색 = 시작점을 찾고
수평 탐색 = 그 지점부터 데이터를 읽어나간다.

고객명이 인덱스로 잡혀있을때
select * from 고객 where 고객명 = "이재희" 라는 sql은 어떻게 동작할까
1. 수직적 탐색
- 고객명이 이재희보다 큰 지점 바로 전으로 진입한다
- 즉 여기서는 고객명 = "정재우"를 만나는순간 그 이전에 해당하는 이재룡을 따라간다
- 이제 우리는 시작점을 찾았다. 이재룡

2. 수평적탐색
- 시작점부터 데이터를 접근하여 조건에 해당하는, 고객명 = "이재희"에 맞는 데이터들은 선택한다.
```

## 인덱스 기본 사용법
- 인덱스를 정상적으로 사용한다는것은 수직 탐색을 통해 스캔 `시작점`을 찾고 수평적 탐색을 통해 데이터에 접근하는것
- 즉, index range scan을 적용하는것

### Index range scan을 할 수 없는 경우
- `인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.`
- 가장 문제가 되는것은 인덱스 선두 컬럼이 가공된 상태로 이 경우는 시작점을 찾을 수 없다.
- 그리고 인덱스 선두 컬럼이 조건절에 있어야 range scan이 가능하다.
- 즉 가공되지 않은 인덱스 선두 컬럼이 조건절 첫번째로 나와야 정상적인 시작점 탐색이 가능하다
```
예시로 
인덱스 : 회원번호 + 회원이름
select * from member
where 회원번호 = 1
and 회원이름 = 2

라는 쿼리문이 존재했을때 
인덱스 선두컬럼이 조건절 맨 앞에 등장하고
이 선두컬럼이 가공되지 않았기때문에 range scan이 가능하여
인덱스를 잘 탄다라고 말할수있다
```
- 그런데 인덱스를 잘탄다고 항상 성능이 우수한건가?
```
예시로
인덱스 : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

select * from Atable
where 기준연도 = :stdr_year(바인드 변수)
and substr(과세구분코드,1,4) = :txtn_dcd
and 보고회차 = 1
and 실명확인번호 = 2

라는 쿼리문이 있다고 해보자
조건절 처음에 인덱스 선두 컬럼이 나오고
또 인덱스 선두 컬럼이 가공되지 않았기 때문에 range scan은 가능하다.
그런데 인덱스 두번째 컬럼이 가공되었다.

만약 기준연도로 시작점을 찾았지만 그 데이터가 백만 천만을 넘어선다면?
두번째 인덱스컬럼은 가공되었기때문에 스캔 범위를 축소시켜주지 못한다.

어쩌면 이런 경우는 인덱스 range scan이 아닌 테이블 풀 스캔이 더 효율적일수도있다.
```
### 인덱스 타는게 항상 좋은건 아니다.
```
index full scan VS table full scan
index는 결국 랜덤 i/o를 사용한다.
만약 우리가 데이터 100% 중 98%를 찾아야하는 상황이라면?

랜덤 i/o는 앞에서 봤듯이 매 번 디스크 헤드를 옮겨 데이터를 찾아야한다
차라리 이런 경우 시퀀셜 액세스+멀티 블록 io를 이용한 테이블 풀 스캔을 활용하면
훨씬 이득일 수 있다.
그러니 인덱스를 잘 탄다고 항상 좋은건 절대 아니다
```
### 인덱스를 활용한 소트 연산 생략
- 인덱스는 정렬되어 있다.
- 이를 잘 활용하면 order by같은 정렬을 할 필요가 없다.
- 정렬되어있기 때문에 select min(~) 혹은 max(~)에서도 활용이 가능하다.

### 컬럼 가공으로 인한 인덱스 사용 실패
- order by절에서 컬럼 가공



