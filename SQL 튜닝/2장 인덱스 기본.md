## 인덱스 구조 및 탐색
- 데이터베이스에서 데이터를 찾는 방법은 두가지다.
  - 테이블 전체를 스캔한다
  - 인덱스를 이용한다.

이러한 인덱스 튜닝 방법의 핵심은 크게 두가지다
- `인덱스 스캔 효율화 튜닝`과 `랜덤 io 최소화 튜닝`
```
예를들어 시력이 1.0~1.5인 홍길동을 찾고자한다고 해보자!!

만약 이름과 시력을 인덱스로 잡으면 먼저 이름으로 정렬, 시력으로 정렬이 되어있을것
이름으로 정렬되어 있으니 홍길동을 찾고, 그 다음 시력 조건을 만족하는동안 수평 스캔을 진행하면 된다.

하지만 만약 시력, 이름으로 인덱스가 잡혀있다면 효율이 매우 나쁘다.
이것이 바로 인덱스 스캔 효율화를 고려하는 튜닝이다.
```
- ![image](https://user-images.githubusercontent.com/62214428/213105706-2db06119-da1c-4695-847b-9a0d2c6e120c.png)
- ★ 다음으로 사실 가장 중요한건 결국 테이블 액세스 횟수를 줄이는것이다
- 인덱스는 랜덤 io를 사용하니 즉. `랜덤 io 최소화 튜닝`

### sql 튜닝은 랜덤 io와의 전쟁이다
```
랜덤 I/O와 순차 I/O

랜덤 I/O는 읽어야하는 데이터가 물리적으로 불연속적으로 있기 때문에 디스크 헤더를 이동 시킨 다음 데이터를 읽는 것을 의미한다. 
이때 디스크 헤드를 이동시키는 시간을 Seek time이라고 한다. 
순차 I/O는 읽어야하는 데이터가 연속적으로 있어 쭉 읽기만 하는 경우를 의미한다.

데이터를 3번 읽어야 한다고 가정하자. 데이터 위치가 물리적으로 연속적이라면 디스크 헤드를 한번 이동시키면 되지만, 불연속적이라면 디스크 헤더를 3번 이동시켜야한다. 
즉, Seek Time이 사실상 디스크에 데이터를 읽고 쓰는데 걸리는 시간을 좌우한다. 
따라서 디스크의 성능은 디스크 헤더의 이동 없이 얼마나 많은 데이터를 순차적으로 저장하느냐에 달렸다.

SSD는 디스크 원판이 없어서 랜덤 I/O와 순차 I/O가 큰 차이가 없을 것 같지만 SSD에서도 랜덤 I/O는 순차 I/O 대비 전체 처리율(throughput)이 떨어진다.

DBMS는 디스크에 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에서는 그룹 커밋이나 바이너리 로그, InnoDB 로그 버퍼등의 기능이 내장되어 있다.

쿼리를 튜닝한다고 랜덤 I/O가 순차 I/O로 변하는 상황은 많지 않다고 한다. 
즉, 쿼리 튜닝의 목적은 랜덤 I/O 횟수 자체를 줄이는 것이다. 
즉, 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것이 중요하다.

인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하고, 풀 테이블 스캔은 순차 I/O를 사용한다. 
따라서 큰 테이블의 레코드를 읽는 작업을 할 때 옵티마이저가 인덱스 대신 풀 테이블 스캔을 하도록 유도하는 경우도 있다고 한다.
```
