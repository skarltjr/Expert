### 들어가기 앞서.. sql 파싱과 최적화
```
sql은 선언적 질의 언어다.
ex) 우리는 "이거이거 해줘"라고 선언할뿐

그리고 이러한 선언으로부터 결과물을 만들어내는 과정은 절차적이다.
즉 우리는 선언할뿐이고 dbms 내부 엔진인 옵티마이저가 
선언으로부터 결과물을 만들어낼 수 있는 프로그래밍을 대신해준다.

이렇게 dbms 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 
과정을 sql 최적화라고한다.
```
### SQL 최적화 과정
```
sql을 실행하기 전 최적화 과정은 다음과 같다.
(우리의 선언으로부터 결과물을 뽑아내는 과정)
```
- 1. sql 파싱
```
먼저 sql parser가 파싱을 진행한다

- 파싱 트리 생성 : sql문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
- syntax 체크 : 문법저 오류를 검증
- semantic 체크 : 의미상 오류가 없는지 확인 / ex) 없는 테이블 검색 시 에러
```
- 2. sql 최적화
```
이제부터 옵티마이저가 선언 내용으로부터 결과물을 뽑아낼 수 있는 프로시저를 작성하고 컴파일해서
실행 가능한 상태로 만든다.

이 단계에서 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 
다양한 실행경로를 생성해서 비교한 후 가장 효율적인 경로를 채택한다.
즉, 성능을 결정하는 핵심
```
- 3. 로우 소스 생성
```
옵티마이저가 선택한 실행 경로를 실제 실행 가능한 코드 또는 프로시저로 만들어낸다.
```

### SQL 옵티마이저
```
옵티마이저는 결국 사용자가 원하는 작업을 "가장 효율적으로" 처리할 수 있는 최적의
데이터 액세스 경로를 선택해주는 dbms의 핵심 엔진이다.

옵티마이저 최적화 단계는 아래와 같은데..
```
- 먼저 사용자로부터 전달받은 쿼리를 수행하는데 후보군이 될만하 실행계획들을 찾는다
- 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용 산정
- 최저 비용(최고 효율) 실행계획 선택

### 실행계획과 비용
```
우리가 네비게이션을 사용할때 최적 경로를 보여준다
옵티마이저 또한 일종의 네비게이션이라고 생각하자
최적의 경로를 제공해주는...
```
- 여기서는 mysql을 사용하며 explain 키워드를 통해 mysql 실행계획 미리보기가 가능하다.
- <img width="779" alt="스크린샷 2023-01-02 오후 10 17 29" src="https://user-images.githubusercontent.com/62214428/210236603-6cc21d49-53d8-43d2-9f8c-bcebb2c1f37c.png">
- <img width="1478" alt="스크린샷 2023-01-02 오후 10 17 16" src="https://user-images.githubusercontent.com/62214428/210236613-a14d6a62-8b22-4c41-96f7-46ee07c2aeef.png">
```
sales left join car
- 결국 sales는 type:all로 모든 컬럼 조회
- car의 경우 pk로 조인하며 type:eq_ref로 
   - 조인수행을 위해 각 테이블에서 하나의 행만이 읽혀지는 형태. const 타입 외에 가장 훌륭한 조인타입이다.
```
- 그런데 결과 산출을 위해 접근되는 rows가 1인게 아직 이해가 안된다....


- 참고 : 
```
pk는 기본적으로 인덱스가 걸린다
&
https://jeong-pro.tistory.com/243
```

### 옵티마이저 힌트
```
네비게이션이 항상 옳은길만 찾아줄까?
옵티마이저 또한 마찬가지다.

이럴때 옵티마이저 힌트를 통해 의도적으로 데이터 액세스 경로를 변경할 수 있다.

나아가 인덱스 a를 사용할게, 조인 방식이나 순서는 옵티마이저 너가 알아서해줘와 같이 
일부만 지시할 수 있는데 이는 잘못된 결과를 만들어낼 수 있다.

⭐️ 그러니 이왕에 힌트를 사용할거면 빈틈없이 기술하라고 한다.
```
```
1번 = explain select * from car where carId = 3;

create index c_maker on car(maker);

show index from car;

2번 = explain select /*+ INDEX(car c_maker) */ * from car where carId = 3; // 옵티마이저 힌트 적용하여 c_maker 인덱스 활용하도록
```
```
실제로 
1,2번의 rows 결과가 다르다 1번은 1/ 2번은 2
즉 불필요한 인덱스 사용으로 악영향도 발생한다.
```

